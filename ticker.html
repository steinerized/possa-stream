<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vertical Ticker 1920x100</title>

  <!-- Google Font (più stabile di @import) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
    }

    :root {
      /* Tipografia */
      --ticker-font-family: "Anton";
      --ticker-font-size: 40px;
      --ticker-color: #FAFAFA;

      /* Ombra testo */
      --ticker-shadow-color: rgba(0,0,0,0.75);
      --ticker-shadow-blur: 6px;
      --ticker-shadow-y: 2px;

      /* Layout */
      --ticker-padding-left: 24px;

      /* Badge */
      --ticker-badge-bg: #fafafa;
      --ticker-badge-gap: 16px;
    }

    /* IMPORTANTISSIMO: CSS size = canvas logical size */
    canvas {
      display: block;
      width: 1920px;
      height: 100px;
      background: transparent;
    }
  </style>
</head>
<body>

  <!-- IMPORTANTISSIMO: attributes width/height = logical size -->
  <canvas id="ticker" width="1920" height="100"></canvas>

  <script>
    // =========================
    // TIMING
    // =========================
    const IN_MS = 1000;
    const HOLD_MS = 60000;
    const OUT_MS = 1000;
    const TOTAL_MS = IN_MS + HOLD_MS + OUT_MS;

    // "BADGE|testo"
    const MESSAGES = [
      "SUPPORTAMI |Scrivi !sub o !prime per evitare le pubblicità",
      "@MatteoTorinoFC |Seguimi su Facebook - Instagram - YouTube - TikTok - X - Twitch - Spotify"
    ];

    const canvas = document.getElementById("ticker");
    const ctx = canvas.getContext("2d");

    // Prendiamo la size LOGICA direttamente dal canvas (1920x100)
    const W = canvas.width;
    const H = canvas.height;

    // =========================
    // CSS vars -> JS
    // =========================
    function cssVar(name, fallback) {
      const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      return v || fallback;
    }
    function cssPx(name, fallback) {
      const v = cssVar(name, "");
      const n = parseFloat(v);
      return Number.isFinite(n) ? n : fallback;
    }

    const FONT_FAMILY = cssVar("--ticker-font-family", "Anton");
    const FONT_SIZE = cssPx("--ticker-font-size", 20);
    const TEXT_COLOR = cssVar("--ticker-color", "#FAFAFA");

    const SHADOW_COLOR = cssVar("--ticker-shadow-color", "rgba(0,0,0)");
    const SHADOW_BLUR = cssPx("--ticker-shadow-blur", 6);
    const SHADOW_Y = cssPx("--ticker-shadow-y", 2);

    const PADDING_LEFT = cssPx("--ticker-padding-left", 24);
    const BADGE_PAD_X = 5; // px padding sinistra/destra badge
    const BADGE_BG = cssVar("--ticker-badge-bg", "rgba(128,0,0)");
    const BADGE_GAP = cssPx("--ticker-badge-gap", 16);

    // =========================
    // HiDPI: aumenta risoluzione REALE, ma coordinate restano W x H
    // =========================
    function setupHiDPI() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      // Manteniamo le dimensioni logiche W,H ma aumentiamo buffer
      canvas.width = Math.round(W * dpr);
      canvas.height = Math.round(H * dpr);

      // Rimettiamo la size CSS coerente (se qualcuno la tocca)
      canvas.style.width = `${W}px`;
      canvas.style.height = `${H}px`;

      // Coordinate logiche
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = true;
    }
    setupHiDPI();

    // =========================
    // UTIL
    // =========================
    function easeInOutCubic(t) {
      return t < 0.5
        ? 4 * t * t * t
        : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    function clear() {
      ctx.clearRect(0, 0, W, H);
    }

    // =========================
    // DRAW
    // =========================
  function drawMessage(raw, y) {
      clear();

      const parts = String(raw).split("|");

      // ✅ uppercase automatico
      const badgeLabel = ((parts[0] ?? "").trim()).toUpperCase();
      const restText  = ((parts[1] ?? "").trim()).toUpperCase();

      // -------------------------
      // BADGE (padding reale simmetrico, misura col font del badge)
      // -------------------------
      const badgePad = BADGE_PAD_X;

      // Imposta il font del badge (+2px) PRIMA di misurare
      ctx.font = `${FONT_SIZE + 2}px ${FONT_FAMILY}, system-ui, Arial, sans-serif`;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";

      const badgeTextW = ctx.measureText(badgeLabel).width;
      const badgeWidth = badgeTextW + badgePad * 2;

      // sfondo badge (alto quanto canvas)
      ctx.fillStyle = BADGE_BG; // #fafafa dal CSS
      ctx.fillRect(PADDING_LEFT, 0, badgeWidth, H);

      // testo badge: NO shadow, #580707
      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      ctx.fillStyle = "#580707";
      ctx.fillText(badgeLabel, PADDING_LEFT + badgePad, y);

      // -------------------------
      // TESTO NORMALE: shadow on, bianco (font base)
      // -------------------------
      if (restText) {
        ctx.font = `${FONT_SIZE}px ${FONT_FAMILY}, system-ui, Arial, sans-serif`;
        ctx.shadowColor = SHADOW_COLOR;
        ctx.shadowBlur = SHADOW_BLUR;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = SHADOW_Y;

        ctx.fillStyle = TEXT_COLOR;
        const afterX = PADDING_LEFT + badgeWidth + BADGE_GAP;
        ctx.fillText(restText, afterX, y);
      }

      // reset shadow
      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
    }

    // =========================
    // ANIMATION (enter/hold/exit)
    // =========================
    const CENTER_Y = H / 2;
    const Y_IN_START = -FONT_SIZE * 2;    // fuori sopra
    const Y_OUT_END = H + FONT_SIZE * 2;  // fuori sotto

    let idx = 0;
    let phaseStartTs = null;

    function animate(ts) {
      if (!phaseStartTs) phaseStartTs = ts;

      const elapsed = ts - phaseStartTs;
      const msg = MESSAGES[idx];

      let y;

      if (elapsed < IN_MS) {
        const t = easeInOutCubic(elapsed / IN_MS);
        y = Y_IN_START + (CENTER_Y - Y_IN_START) * t;
      } else if (elapsed < IN_MS + HOLD_MS) {
        y = CENTER_Y;
      } else if (elapsed < TOTAL_MS) {
        const tRaw = (elapsed - IN_MS - HOLD_MS) / OUT_MS;
        const t = easeInOutCubic(tRaw);
        y = CENTER_Y + (Y_OUT_END - CENTER_Y) * t;
      } else {
        idx = (idx + 1) % MESSAGES.length;
        phaseStartTs = ts;
        y = Y_IN_START;
      }

      drawMessage(msg, y);
      requestAnimationFrame(animate);
    }

    // Start: aspetta Anton prima del primo draw
    (async function start() {
      try {
        await document.fonts.load(`${FONT_SIZE}px ${FONT_FAMILY}`);
        await document.fonts.ready;
      } catch (_) {}
      requestAnimationFrame(animate);
    })();

    window.addEventListener("resize", setupHiDPI);
  </script>

</body>
</html>
